# Tezos DeFi Bots

This repository aims at becoming a collaborative collection of bots used in the Tezos DeFi ecosystem.

The bots can be used from yield farming strategies, to collateral management automation or AMM arbitrages.

Improvements, ideas or new bots are welcome and can be provided in form of pull requests. Discussions
can be started in the issues section.

Feel free to reuse/extend the bots to your likings, everything is MIT licensed. Contributions are very
welcome.

The components are built in an object oriented way, abstracting away smart contract interaction.

Disclaimer: This code is experimental and unreviewed. Make sure to read the code before allowing the bots
to get any access to tokens. It is an experiment, consider the funds you allow the bot to manage lost.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# Youves Collateral Manager

This bot runs a low-risk strategy by minting on youves and providing the minted token in a stable flat-curve. It mints
the maximum (300% collateralisation) and provides it as liquidity to farm. If your collateral (XTZ in this case) drops
below the specified threshold the bot removes the liquidity and burns the minted token to reach the specified threshold.

Because it provides the liquidity on a stable 1:1 flat curve the expected impermanent loss is neglectable.

The yield is generated by the amount of YOU the bot receives for the minting, the fees the bot receives from the liquidity
provision and the rewards it receives from the long-term farm.

## Getting Started

1. installing pytezos
```
pip3 install pytezos
```

2. configuring the collateral manager
```
vim settings.py
```

3. launch
```
python3 collateral_manager.py
```

Also: If you use VS Code you can simply use the provided .devcontainer for execution and development.

## Configuration

The `settings.py` file configures the bot. This is the meaning of the parameters:

- `SHELL`: the tezos node RPC (i.e. https://mainnet.api.tez.ie/)
- `KEY`: the secret used by the bot (i.e. `Key.from_encoded_key(key="edsk..."`)
- `DRY_RUN`: if `True` no operation is broadcasted to the chain. Set to `False` to have it perform transactions on-chain.
- `TARGET_COLLATERAL_RATIO`: target collateralisation ration, this is the max you want to mint. Standard is `3.0`.
- `THRESHOLD_RATIO`: threshold ratio, this is when a burn is triggered. Standard is `2.1` (Youves liquidates at 2.0) 
- `PRICE_THRESHOLD`: threshold at which the bot is allowed to swap the minted asset. Standard is `1.005`, which means we allow up to 0.5% "too expensive" swap.
- `ENGINE_ADDRESS`: Youves tez-collateral engine to use for the minting.
- `BAKER`: Baker you want to set for your Youves vault.
- `FARM_ADDRESS`: Youves farm address to use. 

# Components

## FA1 Token Bot (`fa1_token_bot.py`)

Bot used to abstract the standard functionality of a FA1.x contract. This includes fetching a balance and 
adding operators.

### Methods

- `__init__(self, operator_contract, token_contract_address, shell, key, token_decimals=18)`: constructor
  - `operator_contract`: operator to set for this instance
  - `token_contract_address`: address of the FA1.x token i.e. KT1K9gCRgaLRFKTErYt1wVxA3Frb9FjasjTV (kUSD)
  - `shell`: pytezos shell (aka tezos node), i.e. https://mainnet.api.tez.ie
  - `key`: pytezos key (aka your bot's secret), i.e. `edsk...`
  - `token_decimals`: decimals used for the normalisation of the values provided as token amount (i.e. in get)
- `add_operator(self)`: returns the operations needed to add the operator specified in the constructor
- `approve(self, amount)`: returns the operations needed to approve the specified allowance to the operator specified in the constructor
- `get_balance(self)`: returns the normalised balance.

## FA2 Token Bot (`fa2_token_bot.py`)

Bot used to abstract the standard functionality of a FA2 contract. This includes fetching a balance and 
adding operators.

### Methods

- `__init__(self, operator_contract, token_contract_address, token_id, shell, key, token_decimals=12)`: constructor
  - `operator_contract`: operator to set for this instance
  - `token_contract_address`: address of the FA2 token i.e. KT1XRPEPXbZK25r3Htzp2o1x7xdMMmfocKNW (uUSD)
  - `token_id`: id of the FA2 token
  - `shell`: pytezos shell (aka tezos node), i.e. https://mainnet.api.tez.ie
  - `key`: pytezos key (aka your bot's secret), i.e. `edsk...`
  - `token_decimals`: decimals used for the normalisation of the values provided as token amount (i.e. in get)
- `add_operator(self)`: returns the operations needed to add the operator specifiedin the constructor
- `remove_operator(self)`: returns the operations needed to remove the operator specified in the constructor
- `get_balance(self)`: returns the normalised balance.

## Youves Farm Bot (`farm_bot.py`)

Bot used to abstract the youves reward farm interaction.

### Methods

- `__init__(self, farm_contract_address, token1_decimals, token2_decimals, shell, key)`: constructor
  - `farm_contract_address`: youves farm address, i.e. KT1HaWDWv7XPsZ54JbDquXV6YgyazQr9Jkp3 (uUSD/kUSD long-term) 
  - `token1_decimals`: decimals of the first token
  - `token2_decimals`: decimals of the second token
  - `shell`: pytezos shell (aka tezos node), i.e. https://mainnet.api.tez.ie
  - `key`: pytezos key (aka your bot's secret), i.e. `edsk...`
- `claim(self)`: claim pending rewards
- `withdraw(self)`: withdraw entire stake
- `deposit(self, token_amount)`: deposit the specified token amount
  - `token_amount`: LP token amount to deposit
- `deposit_all(self)`: deposit the entire amount the account has as balance to farm
- `get_own_stake(self)`: returns the stake and % unlocked of this account
 
## Youves Flat CFMM (`flat_cfmm_bot.py`)

Bot used to abstrac the swap interactions.

### Methods

- `__init__(self, dex_contract_address, token1_decimals, token2_decimals, shell, key)`: constructor
- `get_token1_out(self, token2_to_swap, token1_pool=0, token2_pool=0)`: given the amount of token2 to swap, how much token1 do we get out (incl. swap fees)
  - `token2_to_swap`: normalised token2 amount to swap.
  - `token1_pool`: normalised token1_pool used for the calculation. If none is set the storage on-chain is read.
  - `token2_pool`: normalised token2_pool used for the calculation. If none is set the storage on-chain is read.
- `get_token2_out(self, token1_to_swap, token1_pool=0, token2_pool=0)`: given the amount of token2 to swap, how much token1 do we get out (incl. swap fees)
  - `token1_to_swap`: normalised token1 amount to swap.
  - `token1_pool`: normalised token1_pool used for the calculation. If none is set the storage on-chain is read.
  - `token2_pool`: normalised token2_pool used for the calculation. If none is set the storage on-chain is read.
- `get_price(self)`: get the marginal price (no swap fees)
- `swap_token1(self, token1_to_swap, token1_pool=0, token2_pool=0)`: create operations to swap token1 for token2
  - `token1_to_swap`: normalised token1 amount to swap.
  - `token1_pool`: normalised token1_pool used for the calculation. If none is set the storage on-chain is read.
  - `token2_pool`: normalised token2_pool used for the calculation. If none is set the storage on-chain is read.
- `swap_token2(self, token2_to_swap, token1_pool=0, token2_pool=0)`: create operations to swap token1 for token2
  - `token2_to_swap`: normalised token1 amount to swap.
  - `token1_pool`: normalised token1_pool used for the calculation. If none is set the storage on-chain is read.
  - `token2_pool`: normalised token2_pool used for the calculation. If none is set the storage on-chain is read.
- `get_expected_token1_amount(self, liquidity_token_amount, token1_pool=0, token2_pool=0)`: if we were to swap all liquidity tokens to token1, what is the expected token1 amount going to be.
  - `liquidity_token_amount`: amount of LP token
  - `token1_pool`: normalised token1_pool used for the calculation. If none is set the storage on-chain is read.
  - `token2_pool`: normalised token2_pool used for the calculation. If none is set the storage on-chain is read.
- `get_expected_token2_amount(self, liquidity_token_amount, token1_pool=0, token2_pool=0)`: if we were to swap all liquidity tokens to token2, what is the expected token2 amount going to be.
  - `liquidity_token_amount`: amount of LP token
  - `token1_pool`: normalised token1_pool used for the calculation. If none is set the storage on-chain is read.
  - `token2_pool`: normalised token2_pool used for the calculation. If none is set the storage on-chain is read.
- `get_expected_token_amounts(self, liquidity_token_amount, token1_pool=0, token2_pool=0)`: if we were to withdraw our liquidity how many tokens would we get.
  - `liquidity_token_amount`: amount of LP token
  - `token1_pool`: normalised token1_pool used for the calculation. If none is set the storage on-chain is read.
  - `token2_pool`: normalised token2_pool used for the calculation. If none is set the storage on-chain is read.
- `add_max_liquidity(self)`: given our balances of token1 and token2, create operations to provide the maximum amount of liquidity, this will also swap to get the correct ratio between token1 and token2.
- `add_liquidity(self, token1_amount, token2_amount)`: create the operations to provide liquidity to the pool.
  - `token1_amount`: normalised token1_amount
  - `token2_amount`: normalised token2_amount
- `remove_liquidity(self, liquidity_token_amount)`: remove liquidity from the pool.
  - `liquidity_token_amount`: amount of LP token
- `remove_liquidity_to_token1(self, liquidity_token_amount)`: remove liquidity from the pool and swap so that you end up just with token1
  - `liquidity_token_amount`: amount of LP token
- `remove_liquidity_to_token2(self, liquidity_token_amount)`: remove liquidity from the pool and swap so that you end up just with token2
  - `liquidity_token_amount`: amount of LP token
- `add_token1_liquidity(self, token1_amount)`: add liquidity by just providing token1. This will first swap into the correct ration and then provide the two tokens as liquidity.
  - `token1_amount`: normalised token1_amount
- `add_token2_liquidity(self, token2_amount)`: add liquidity by just providing token1. This will first swap into the correct ration and then provide the two tokens as liquidity.
  - `token2_amount`: normalised token1_amount

